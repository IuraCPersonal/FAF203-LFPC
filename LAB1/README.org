#+TITLE: Laboratory Task #1
#+AUTHOR: FCIM FAF-203 Cius Iurie
#+DESCRIPTION: Regular or context free grammar V-4
#+STARTUP: showeverything
#+PROPERTY: header-args :tangle script.py
#+OPTIONS: tex:t

* LABORATORY TASKS

1. For the formal grammar *G=(VN, VT, P, S)* need be obtained five strings, that belong to the language *L(G)*, that is generated by this grammar. The length of strings must be no lesser than the number of characters from the alphabet $V_N+2$.
2. For each string build the noninverted (derivation) tree and derivation table.
3. Convert regular grammar to Finite Automaton (FA).
4. Determine the grammar type by the Chromsky classification.

* THEORETICAL NOTES

A *grammar* is an ordered quadruple $G = (V_N, V_T , P, S)$, where:

+ $V_N$ is the alphabet of variables (or nonterminal symbols),
+ $V_T$ is the alphabet of terminal symbols,
+ P - set of productions, which are rules for replacing (or rewriting) nonterminal symbols (on the left side of the production) in a string with other nonterminal or terminal symbols (on the right side of the production).
+ $S \subset V_N$, S - start symbol, which is a special nonterminal symbol that appears in the initial string generated by the grammar

* IMPLEMENTATION

** Setup Script

A few imports and variables required.

*** Import required libraries

#+begin_src python
import os
import graphviz as gz
#+end_src

*** Initialize the formal grammar

Setup the Grammar and the Set of Productions of Rules.

#+begin_src python
non_terminal_symbols = ['S', 'L', 'D'] 
terminal_symbols = ['a', 'b', 'c', 'd', 'e', 'f', 'j']

set_of_productions = tuple([
    ('S', 'aS'),
    ('S', 'bS'),
    ('S', 'cD'),
    ('S', 'dL'),
    ('S', 'e'),
    ('L', 'eL'),
    ('L', 'fL'),
    ('L', 'jD'),
    ('L', 'e'),
    ('D', 'eD'),
    ('D', 'd')
])
#+end_src

** Link The States

This is just to display the proper names of the states (q1, q2, q3 instead of S, L, M and so on).

#+begin_src python
g_dict = {}
count = 0

for element in non_terminal_symbols:
    g_dict[element] = "q{}".format(count)
    count += 1

g_dict['Q'] = "q{}".format(count + 1)
#+end_src

** Hash Map

Converting the Set of Productions into a Dictionary.

#+begin_src python
__set_of_productions = {}

for nonterminal in set_of_productions:
    __set_of_productions[nonterminal[0]] = [production[1]
                                            for production in set_of_productions if production[0] == nonterminal[0]]
#+end_src

** Finite Automaton

Computing the Finite Automaton (FA).

#+begin_src python
finite_automaton = dict()
for non_terminal in __set_of_productions:
    finite_automaton[g_dict[non_terminal]] = []
    for transition in __set_of_productions[non_terminal]:
        if len(transition) == 2:
            finite_automaton[g_dict[non_terminal]].append(
                (transition[0], g_dict[transition[1]]))
        else:
            finite_automaton[g_dict[non_terminal]].append((transition, 'Q'))


# DEBUG:
print('Finite Automaton:')
print(finite_automaton)
#+end_src

** Check String

Function to check if the given string belongs to the language L(G).

*** TODO This function can and must be improved. This is a dumb way to check.

#+begin_src python
def is_accepted(string, adjacency_matrix, start_node='q0'):
    # Set the current node to the start one.
    current_node = start_node
    for c in string:
        if current_node == 'Q':
            return False

        for weight, adj_node in adjacency_matrix[current_node]:
            if c == weight:
                current_node = adj_node
                break
        else:
            return False

    # Check if the last node is other then Empty.
    if current_node != 'Q':
        for prod in adjacency_matrix[current_node]:
            # If there exists a prod with the exact weight like the last character
            # and the adjacency node empty.
            if prod[0] == string[-1] and prod[1] == 'Q':
                return True

    # Return True or False if the current (last) node is the empty one.
    return current_node == 'Q'
#+end_src

* BONUS POINT

Plot the FA graph. I am using [[https://graphviz.org/][Graphviz]].

#+begin_src python
# Initialize the Graph.
G = gz.Digraph()
G.attr(rankdir='LR', size='8,5')

# Compute all nodes.
for element in finite_automaton:
    for weight, adj_node in finite_automaton[element]:
        G.attr('node', shape='circle')
        G.node(element)

        # Check for the empty node.
        if adj_node == 'Q':
            G.attr('node', shape='doublecircle')
            G.node(adj_node)
        else:
            G.attr('node', shape='circle')
            G.node(adj_node)

        # Add the labels.
        G.edge(element, adj_node, label=weight)

# Add the start arrow.
G.attr('node', shape='none')
G.node('')
G.edge('', 'q0')

# Show/Export the Graph.
# G.view()
#+end_src
